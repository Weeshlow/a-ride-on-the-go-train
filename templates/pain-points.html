<template>
  <section>
    <section>
      <h1>Pain Points</h1>
    </section>

    <section>
      <h3>"Golang: 100% Perfect, 90% of the time."</h3>
    </section>

    <section>
      <h3>No Generics</h3>
      <ul>
        <li>Golang has no support for generics</li>
        <li>"Generics may well be added at some point. We don't feel an urgency for them, although we understand some programmers do."</li>
      </ul>
    </section>

    <section>
      <h3>No Generics - cont</h3>
      <ul>
        <li>While interfaces provide similar functionality, you are losing both syntactic sugar, speed, and compile-time safety</li>
      </ul>
      <p>Example "generic" go code:</p>
      <pre><code class="go">
        func DoSomething(arg interface{}) {
            switch t := arg.(type) {
                case float64:
                    fmt.Printf("is a float64 %f\n", t)
                case int32:
                    fmt.Printf("is an int32 %d\n", t)
                case string:
                    fmt.Printf("is a string %s\n", t)
                case default:
                    fmt.Println("is not recognized")
            }
        }
      </code></pre>
    </section>

    <section>
      <h3>No Generics - cont</h3>
      <ul>
        <li>Using interfaces aren't the end of the world, but it can get tedious</li>
      </ul>
      <p>Sorting a slice of structs:</p>
      <pre><code class="go">
        type MyStruct {
            Attr int
        }

        type MyStructSortable []MyStruct

        func (s MyStructSortable) Len() int {
            return len(s)
        }
        func (s MyStructSortable) Swap(i, j int) {
            s[i], s[j] = s[j], s[i]
        }
        func (s MyStructSortable) Less(i, j int) bool {
            return s[i].Attr < s[j].Attr
        }
      </code></pre>
    </section>

    <section>
      <h3>No Overloading</h3>
      <ul>
        <li>Golang does not support overloading</li>
        <li>Compounded with the strict static typing, can make numerical code<b>painful</b></li>
      </ul>
      <pre><code class="go">
        // all "math" package methods use float64
        func myFunc(val int64) {
            rounded := math.Round(10.345345) // returns float64
            return int64(10) + val + int64(rounded)
        }
      </code></pre>
    </section>

    <section>
      <h3>Error Checking</h3>
      <ul>
        <li>Lots and lots of tedious error checking</li>
        <li>Personally I like the explicit nature of it</li>
      </ul>
      <pre><code class="go">
        func DoSomething() error {
            a, err := stepOne()
            if err != nil {
                return err
            }
            b, err := stepTwo(a)
            if err != nil {
                return err
            }
            c, err := stepThree(b)
            if err != nil {
              return err
            }
            return stepFour(c)
        }
      </code></pre>
    </section>

    <section>
      <h3>Error Checking - cont</h3>
      <ul>
        <li>Checking error by type, not too bad if package exports the error type</li>
      </ul>
      <pre><code class="go">
        func DoSomething() error {
            data, err := conn.Read()
            if err != nil {
                switch e := err.(type) {
                    case lib.ErrThisType:
                        fmt.Println("Do this")
                    case lib.ErrThatType:
                        fmt.Println("Do that")
                    case lib.ErrWhatever:
                        fmt.Println("Do whatever")
                    default"
                        fmt.Println("Who cares")
                }
                return err
            }
            return nil
        }
      </code></pre>
    </section>

  </section>

</template>
